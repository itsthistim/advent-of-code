"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const got_1 = __importDefault(require("got"));
const fs_1 = require("fs");
const utils_1 = require("ts-jest/utils");
const _1 = __importDefault(require("."));
jest.mock('fs', () => ({
    promises: {
        readFile: jest.fn().mockRejectedValue(Error("No such file or directory, open 'filename'")),
        writeFile: jest.fn(),
    },
}));
jest.mock('got', () => jest.fn().mockResolvedValue('Input from web'));
const readFileMock = (0, utils_1.mocked)(fs_1.promises.readFile);
const writeFileMock = (0, utils_1.mocked)(fs_1.promises.writeFile);
const gotMock = (0, utils_1.mocked)(got_1.default);
describe('aocLoader', () => {
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should throw if no session token is given nor AOC_SESSION is set', () => __awaiter(void 0, void 0, void 0, function* () {
        yield expect((0, _1.default)(2020, 1)).rejects.toThrow('No session provided or exist as the AOC_SESSION environment variable');
    }));
    it('should use the session argument before AOC_SESSION', () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.AOC_SESSION = 'env-var-token';
        const sessionArgument = 'argument-token';
        yield (0, _1.default)(2020, 1, sessionArgument);
        expect(gotMock).toHaveBeenCalledWith(expect.anything(), expect.objectContaining({ headers: { Cookie: `session=${sessionArgument}` } }));
    }));
    it('should use the AOC_SESSION environment if no session argument is given', () => __awaiter(void 0, void 0, void 0, function* () {
        const envVar = 'env-var-token';
        process.env.AOC_SESSION = envVar;
        yield (0, _1.default)(2020, 1);
        expect(gotMock).toHaveBeenCalledWith(expect.anything(), expect.objectContaining({ headers: { Cookie: `session=${envVar}` } }));
    }));
    it('should throw if the input is not cached and request fails', () => __awaiter(void 0, void 0, void 0, function* () {
        gotMock.mockRejectedValueOnce(Error('Failed to fetch input'));
        yield expect((0, _1.default)(2020, 1, 'session-token')).rejects.toThrow('Failed to fetch AoC data for year 2020 day 1: Failed to fetch input');
    }));
    it('should not write to cache if request fails', () => __awaiter(void 0, void 0, void 0, function* () {
        gotMock.mockRejectedValueOnce('Failed to fetch input');
        yield expect((0, _1.default)(2020, 1, 'session-token')).rejects.toThrow();
        expect(writeFileMock).not.toHaveBeenCalled();
    }));
    it('should fetch input data from adventofcode.com', () => __awaiter(void 0, void 0, void 0, function* () {
        yield expect((0, _1.default)(2017, 25, 'session-token')).resolves.toEqual('Input from web');
        expect(gotMock).toHaveBeenCalledWith('https://adventofcode.com/2017/day/25/input', expect.anything());
    }));
    it('should write to cache file if request is successful and cache does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
        yield expect((0, _1.default)(2020, 1, 'session-token')).resolves.toEqual('Input from web');
        expect(writeFileMock).toHaveBeenCalledWith(expect.anything(), 'Input from web');
    }));
    it('should read cache file if it exist and not request input anew', () => __awaiter(void 0, void 0, void 0, function* () {
        readFileMock.mockResolvedValueOnce(Buffer.from('Input from file', 'utf8'));
        yield expect((0, _1.default)(2019, 5, 'session-token')).resolves.toEqual('Input from file');
        expect(readFileMock).toHaveBeenCalled();
        expect(gotMock).not.toHaveBeenCalled();
    }));
    it('should remove trailing newline from input', () => __awaiter(void 0, void 0, void 0, function* () {
        gotMock.mockResolvedValueOnce('Input from web\n');
        yield expect((0, _1.default)(2020, 1, 'session-token')).resolves.toEqual('Input from web');
    }));
});
